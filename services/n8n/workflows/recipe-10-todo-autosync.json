{
  "name": "Recipe 10: TODO.md Auto-sync",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 24
            }
          ]
        },
        "triggerTimes": {
          "item": [
            {
              "hour": 8,
              "minute": 5
            }
          ]
        }
      },
      "id": "cron-trigger",
      "name": "Every Morning 08:05 JST",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [
        250,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Calculate today's date for latest digest\nconst now = new Date();\nconst year = now.getFullYear();\nconst month = String(now.getMonth() + 1).padStart(2, '0');\nconst day = String(now.getDate()).padStart(2, '0');\nconst dateString = `${year}-${month}-${day}`;\n\n// Calculate yesterday as fallback\nconst yesterday = new Date(now);\nyesterday.setDate(yesterday.getDate() - 1);\nconst yYear = yesterday.getFullYear();\nconst yMonth = String(yesterday.getMonth() + 1).padStart(2, '0');\nconst yDay = String(yesterday.getDate()).padStart(2, '0');\nconst yesterdayString = `${yYear}-${yMonth}-${yDay}`;\n\n// TEST MODE: Use today's date for testing new tags\n// Set to false for production (reads yesterday's digest at 08:05)\nconst testMode = false;\nconst basePath = '/workspace/dauberside.github.io-1';\nconst testDigestPath = testMode \n  ? `${basePath}/cortex/daily/${dateString}-digest.md`\n  : `${basePath}/cortex/daily/${yesterdayString}-digest.md`;\n\nreturn {\n  json: {\n    date: dateString,\n    yesterdayDate: yesterdayString,\n    digestPath: testDigestPath,\n    todoPath: `TODO.md`\n  }\n};"
      },
      "id": "calculate-date",
      "name": "Calculate Dates",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        450,
        300
      ]
    },
    {
      "parameters": {
        "operation": "read",
        "fileSelector": "={{ $json.digestPath }}"
      },
      "id": "read-digest",
      "name": "Read Latest Daily Digest",
      "type": "n8n-nodes-base.readWriteFile",
      "typeVersion": 1,
      "position": [
        650,
        300
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst dateInfo = $('Calculate Dates').first().json;\n\n// Get digest content\nlet digestText = '';\nif (items[0] && items[0].binary && items[0].binary.data) {\n  const buffer = Buffer.from(items[0].binary.data.data, 'base64');\n  digestText = buffer.toString('utf8');\n}\n\n// Define section patterns to search (in priority order)\nconst sectionPatterns = [\n  { pattern: /^##\\s+Today's Focus/i, name: \"Today's Focus\" },\n  { pattern: /^##\\s+Action Items/i, name: 'Action Items' },\n  { pattern: /^##\\s+Follow-ups/i, name: 'Follow-ups' },\n  { pattern: /^##\\s+Priority\\s+[12]/i, name: 'Priority 1/2' }\n];\n\n// Find the first matching section\nconst lines = digestText.split('\\n');\nlet targetSectionStart = -1;\nlet targetSectionEnd = -1;\nlet foundSection = null;\n\nfor (const { pattern, name } of sectionPatterns) {\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    \n    if (line.trim().match(pattern)) {\n      targetSectionStart = i;\n      foundSection = name;\n      \n      // Find the end of this section (next ## heading or EOF)\n      targetSectionEnd = lines.length;  // Default to EOF\n      for (let j = i + 1; j < lines.length; j++) {\n        if (lines[j].trim().match(/^##\\s+/)) {\n          targetSectionEnd = j;\n          break;\n        }\n      }\n      \n      break;  // Found a section, stop searching this pattern\n    }\n  }\n  \n  if (targetSectionStart !== -1) {\n    break;  // Found a section, stop trying other patterns\n  }\n}\n\n// Extract lines from the found section\nlet focusSectionLines = [];\nif (targetSectionStart !== -1) {\n  focusSectionLines = lines.slice(targetSectionStart + 1, targetSectionEnd);\n}\n\n// Define tag ‚Üí emoji mapping (priority order)\nconst tagEmojiMap = [\n  { tag: 'urgent', emoji: '‚ö°' },      // P0: Time-critical tasks\n  { tag: 'blocked', emoji: 'üöß' },    // P1: Blocked by external dependency\n  { tag: 'waiting', emoji: '‚è≥' },    // P2: Waiting for response/input\n  { tag: 'deepwork', emoji: 'üéØ' },   // P3: Requires focus/concentration\n  { tag: 'review', emoji: 'üëÅÔ∏è' }      // P4: Review/checking work\n];\n\n// Extract uncompleted tasks from the section\nconst uncompletedTasks = focusSectionLines\n  .filter(line => line.trim().match(/^-\\s*\\[\\s*\\]/))\n  .map(line => {\n    const taskText = line.trim();\n    \n    // Determine category based on content\n    let category = null;\n    if (taskText.match(/cortex\\//i)) {\n      category = 'Cortex';\n    } else if (taskText.match(/n8n|recipe\\s+\\d+/i)) {\n      category = 'n8n';\n    }\n    \n    // Extract tags from task text\n    const tags = [];\n    const tagPattern = /#(\\w+)/g;\n    let match;\n    while ((match = tagPattern.exec(taskText)) !== null) {\n      tags.push(match[1].toLowerCase());\n    }\n    \n    // Find matching emoji (first match in priority order)\n    let emoji = null;\n    for (const { tag, emoji: emojiChar } of tagEmojiMap) {\n      if (tags.includes(tag)) {\n        emoji = emojiChar;\n        break;\n      }\n    }\n    \n    return {\n      raw: taskText,\n      category: category,\n      text: taskText,\n      section: foundSection,\n      tags: tags,\n      emoji: emoji\n    };\n  });\n\n// Remove duplicates based on raw text\nconst seen = new Set();\nconst uniqueTasks = uncompletedTasks.filter(task => {\n  if (seen.has(task.raw)) {\n    return false;\n  }\n  seen.add(task.raw);\n  return true;\n});\n\nreturn {\n  json: {\n    date: dateInfo.date,\n    yesterdayDate: dateInfo.yesterdayDate,\n    todoPath: dateInfo.todoPath,\n    uncompletedTasks: uniqueTasks,\n    taskCount: uniqueTasks.length,\n    sourceSection: foundSection || 'None'\n  }\n};"
      },
      "id": "extract-tasks",
      "name": "Extract Uncompleted Tasks",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        850,
        300
      ]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://host.docker.internal:27124/vault/TODO.md",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Bearer ' + $env.OBSIDIAN_API_KEY }}"
            }
          ]
        },
        "options": {
          "timeout": 10000,
          "allowUnauthorizedCerts": true
        }
      },
      "id": "read-todo",
      "name": "Read TODO.md",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1050,
        300
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Recipe 10: Fixed Merge Logic\n// Issue: Regex doesn't properly remove old \"## Today\" section with subsections\n\nconst taskInfo = $('Extract Uncompleted Tasks').first().json;\nconst httpResponse = $input.first().json;\n\nfunction unwrapContent(raw) {\n  if (typeof raw !== 'string') return '';\n  let current = raw;\n  while (true) {\n    try {\n      const parsed = JSON.parse(current);\n      if (parsed && typeof parsed.content === 'string') {\n        current = parsed.content;\n        continue;\n      }\n      break;\n    } catch (e) {\n      break;\n    }\n  }\n  return current;\n}\n\n// Get existing TODO.md content\nlet todoContent = '';\n\nif (httpResponse && typeof httpResponse === 'object') {\n  if (typeof httpResponse.content === 'string') {\n    todoContent = unwrapContent(httpResponse.content);\n  } else if (typeof httpResponse.data === 'string') {\n    todoContent = unwrapContent(httpResponse.data);\n  } else if (typeof httpResponse.body === 'string') {\n    todoContent = unwrapContent(httpResponse.body);\n  } else if (httpResponse.data && typeof httpResponse.data.content === 'string') {\n    todoContent = unwrapContent(httpResponse.data.content);\n  }\n} else if (typeof httpResponse === 'string') {\n  todoContent = unwrapContent(httpResponse);\n}\n\nif (!todoContent) {\n  todoContent = '';\n}\n\n// Parse existing TODO sections\nconst lines = todoContent.split('\\n');\nconst existingTasks = lines\n  .filter(line => line.trim().match(/^-\\s*\\[/))\n  .map(line => line.trim());\n\n// Helper function to normalize task text for deduplication\nfunction normalizeTask(taskLine) {\n  return taskLine\n    .replace(/^-\\s*\\[\\s*\\]\\s*/, '')     // Remove checkbox\n    .replace(/^\\[.*?\\]\\s*/, '')          // Remove category prefix\n    .replace(/^[‚ö°üöß‚è≥üéØüëÅÔ∏è]\\s*/, '')     // Remove emoji\n    .replace(/\\s*<!--.*?-->\\s*$/, '')   // Remove HTML comment\n    .trim();\n}\n\n// Format new tasks with category, emoji, and tags\nconst formattedTasks = taskInfo.uncompletedTasks.map(task => {\n  // Remove the \"- [ ] \" prefix and any existing tags from content\n  let taskContent = task.raw.replace(/^-\\s*\\[\\s*\\]\\s*/, '');\n  \n  // Remove inline tags from the content (they'll be in the comment)\n  taskContent = taskContent.replace(/#\\w+/g, '').trim();\n  \n  // Build the formatted task\n  let formatted = '- [ ]';\n  \n  // Add category if exists\n  if (task.category) {\n    formatted += ` [${task.category}]`;\n  }\n  \n  // Add emoji if exists\n  if (task.emoji) {\n    formatted += ` ${task.emoji}`;\n  }\n  \n  // Add task content\n  formatted += ` ${taskContent}`;\n  \n  // Add tags comment if exists\n  if (task.tags && task.tags.length > 0) {\n    const tagsList = task.tags.map(t => `#${t}`).join(',');\n    formatted += `  <!-- ${tagsList} -->`;\n  }\n  \n  return formatted;\n});\n\n// Filter out tasks that already exist in TODO (compare normalized content only)\nconst newTasks = formattedTasks.filter(formattedTask => {\n  const newTaskNormalized = normalizeTask(formattedTask);\n  \n  return !existingTasks.some(existing => {\n    const existingNormalized = normalizeTask(existing);\n    return existingNormalized === newTaskNormalized;\n  });\n});\n\n// Categorize tasks by urgency for structured output\nconst urgentTasks = newTasks.filter(t => t.includes('<!-- #urgent'));\nconst regularTasks = newTasks.filter(t => !t.includes('<!-- #urgent'));\n\n// Build new section for today with proper structure\nconst today = taskInfo.date;\nlet newSection = `## Today ‚Äî ${today}\\n\\n`;\n\n// High Priority section\nnewSection += '### High Priority\\n';\nif (urgentTasks.length > 0) {\n  urgentTasks.forEach(task => {\n    newSection += `${task}\\n`;\n  });\n} else {\n  newSection += 'Ôºà„Çø„Çπ„ÇØ„Å™„ÅóÔºâ\\n';\n}\nnewSection += '\\n';\n\n// Regular Tasks section\nnewSection += '### Regular Tasks\\n';\nif (regularTasks.length > 0) {\n  regularTasks.forEach(task => {\n    newSection += `${task}\\n`;\n  });\n} else {\n  newSection += 'Ôºà„Çø„Çπ„ÇØ„Å™„ÅóÔºâ\\n';\n}\n\nnewSection += '\\n---\\n';\n\n// FIX: Remove old \"## Today ‚Äî\" section completely (including all subsections until ---)\n// Strategy: Match \"## Today ‚Äî\" and everything until (and including) the \"---\" separator\nconst todayRegex = /^## Today ‚Äî \\d{4}-\\d{2}-\\d{2}\\s*\\n[\\s\\S]*?^---\\s*$/m;\n\nlet updatedContent = todoContent.replace(todayRegex, '').trim();\n\n// Add new section at the top\nupdatedContent = newSection + '\\n' + updatedContent;\n\nreturn {\n  json: {\n    date: today,\n    todoPath: taskInfo.todoPath,\n    newTasksCount: newTasks.length,\n    totalTasksCount: taskInfo.taskCount,\n    urgentCount: urgentTasks.length,\n    regularCount: regularTasks.length,\n    updatedContent,\n    newTasks,\n  },\n};\n"
      },
      "id": "merge-tasks",
      "name": "Merge Tasks into TODO",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1250,
        300
      ]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "https://host.docker.internal:27124/vault/TODO.md",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Bearer ' + $env.OBSIDIAN_API_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { \"content\": $json.updatedContent } }}",
        "options": {
          "timeout": 10000,
          "allowUnauthorizedCerts": true
        }
      },
      "id": "update-todo",
      "name": "Update TODO.md",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1450,
        300
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SLACK_DAILY_DIGEST_WEBHOOK }}",
        "authentication": "none",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { \"text\": \"‚úÖ TODO.md Auto-syncÂÆå‰∫Ü\\n‚Ä¢ Êó•‰ªò: \" + $('Merge Tasks into TODO').item.json.date + \"\\n‚Ä¢ Êñ∞Ë¶è„Çø„Çπ„ÇØ: \" + $('Merge Tasks into TODO').item.json.newTasksCount + \" ‰ª∂\\n‚Ä¢ „ÇΩ„Éº„Çπ: \" + $('Extract Uncompleted Tasks').item.json.sourceSection } }}",
        "options": {}
      },
      "id": "slack-notification",
      "name": "Send to Slack",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1650,
        300
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Prepare JSONL log entry for Recipe 10\nconst mergeData = $('Merge Tasks into TODO').first().json;\nconst extractData = $('Extract Uncompleted Tasks').first().json;\nconst updateData = $('Update TODO.md').first().json;\n\n// Calculate duration (use reasonable default if not available)\nconst startTime = $('Every Morning 08:05 JST').first().json.startTime || Date.now();\nconst endTime = Date.now();\nconst durationMs = endTime - startTime;\n\n// Determine status and error message\nlet status = 'success';\nlet errorMessage = null;\nconst warnings = [];\n\n// Add warnings if no tasks were added\nif (mergeData.newTasksCount === 0) {\n  warnings.push('No new tasks extracted');\n}\n\n// Build meta object\nconst meta = {\n  tasksAdded: mergeData.newTasksCount || 0,\n  totalTasks: extractData.taskCount || 0,\n  sourceSection: extractData.sourceSection || 'None',\n  statusCode: updateData.statusCode || 204,\n  target: 'vault/TODO.md'\n};\n\nif (warnings.length > 0) {\n  meta.warnings = warnings;\n}\n\n// Build log entry\nconst logEntry = {\n  ts: new Date().toISOString(),\n  workflow: 'Recipe 10: TODO.md Auto-sync',\n  executionId: $executionId,\n  status: status,\n  durationMs: durationMs,\n  env: 'production',\n  errorMessage: errorMessage,\n  meta: meta\n};\n\n// Create filename with today's date\nconst today = mergeData.date || new Date().toISOString().split('T')[0];\nconst filename = `cortex/logs/recipe-10-${today}.jsonl`;\n\n// Create the log line (single line JSON)\nconst logLine = JSON.stringify(logEntry);\n\nreturn {\n  json: {\n    logEntry: logEntry,\n    logLine: logLine,\n    filename: filename\n  }\n};"
      },
      "id": "prepare-log",
      "name": "Prepare Log Entry",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1850,
        300
      ]
    },
    {
      "parameters": {
        "command": "={{ \"echo '\" + $json.logLine + \"' >> /workspace/dauberside.github.io-1/\" + $json.filename }}",
        "options": {}
      },
      "id": "write-log",
      "name": "Write JSONL Log",
      "type": "n8n-nodes-base.executeCommand",
      "typeVersion": 1,
      "position": [
        2050,
        300
      ],
      "onError": "continueRegularOutput"
    }
  ],
  "connections": {
    "Every Morning 08:05 JST": {
      "main": [
        [
          {
            "node": "Calculate Dates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Dates": {
      "main": [
        [
          {
            "node": "Read Latest Daily Digest",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Latest Daily Digest": {
      "main": [
        [
          {
            "node": "Extract Uncompleted Tasks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Uncompleted Tasks": {
      "main": [
        [
          {
            "node": "Read TODO.md",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read TODO.md": {
      "main": [
        [
          {
            "node": "Merge Tasks into TODO",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Tasks into TODO": {
      "main": [
        [
          {
            "node": "Update TODO.md",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update TODO.md": {
      "main": [
        [
          {
            "node": "Send to Slack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send to Slack": {
      "main": [
        [
          {
            "node": "Prepare Log Entry",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Log Entry": {
      "main": [
        [
          {
            "node": "Write JSONL Log",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}