{
  "name": "Recipe 10: TODO.md Auto-sync",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 24
            }
          ]
        },
        "triggerTimes": {
          "item": [
            {
              "hour": 8,
              "minute": 5
            }
          ]
        }
      },
      "id": "cron-trigger",
      "name": "Every Morning 08:05 JST",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "jsCode": "// Calculate today's date for latest digest\nconst now = new Date();\nconst year = now.getFullYear();\nconst month = String(now.getMonth() + 1).padStart(2, '0');\nconst day = String(now.getDate()).padStart(2, '0');\nconst dateString = `${year}-${month}-${day}`;\n\n// Calculate yesterday as fallback\nconst yesterday = new Date(now);\nyesterday.setDate(yesterday.getDate() - 1);\nconst yYear = yesterday.getFullYear();\nconst yMonth = String(yesterday.getMonth() + 1).padStart(2, '0');\nconst yDay = String(yesterday.getDate()).padStart(2, '0');\nconst yesterdayString = `${yYear}-${yMonth}-${yDay}`;\n\n// TEST MODE: Use today's date for testing new tags\n// Set to false for production (reads yesterday's digest at 08:05)\nconst testMode = false;\nconst basePath = '/workspace/dauberside.github.io-1';\nconst testDigestPath = testMode \n  ? `${basePath}/cortex/daily/${dateString}-digest.md`\n  : `${basePath}/cortex/daily/${yesterdayString}-digest.md`;\n\nreturn {\n  json: {\n    date: dateString,\n    yesterdayDate: yesterdayString,\n    digestPath: testDigestPath,\n    todoPath: `TODO.md`\n  }\n};"
      },
      "id": "calculate-date",
      "name": "Calculate Dates",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "operation": "read",
        "fileSelector": "={{ $json.digestPath }}"
      },
      "id": "read-digest",
      "name": "Read Latest Daily Digest",
      "type": "n8n-nodes-base.readWriteFile",
      "typeVersion": 1,
      "position": [650, 300],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\nconst dateInfo = $('Calculate Dates').first().json;\n\n// Get digest content\nlet digestText = '';\nif (items[0] && items[0].binary && items[0].binary.data) {\n  const buffer = Buffer.from(items[0].binary.data.data, 'base64');\n  digestText = buffer.toString('utf8');\n}\n\n// Define section patterns to search (in priority order)\nconst sectionPatterns = [\n  { pattern: /^##\\s+Today's Focus/i, name: \"Today's Focus\" },\n  { pattern: /^##\\s+Action Items/i, name: 'Action Items' },\n  { pattern: /^##\\s+Follow-ups/i, name: 'Follow-ups' },\n  { pattern: /^##\\s+Priority\\s+[12]/i, name: 'Priority 1/2' }\n];\n\n// Find the first matching section\nconst lines = digestText.split('\\n');\nlet targetSectionStart = -1;\nlet targetSectionEnd = -1;\nlet foundSection = null;\n\nfor (const { pattern, name } of sectionPatterns) {\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    \n    if (line.trim().match(pattern)) {\n      targetSectionStart = i;\n      foundSection = name;\n      \n      // Find the end of this section (next ## heading or EOF)\n      targetSectionEnd = lines.length;  // Default to EOF\n      for (let j = i + 1; j < lines.length; j++) {\n        if (lines[j].trim().match(/^##\\s+/)) {\n          targetSectionEnd = j;\n          break;\n        }\n      }\n      \n      break;  // Found a section, stop searching this pattern\n    }\n  }\n  \n  if (targetSectionStart !== -1) {\n    break;  // Found a section, stop trying other patterns\n  }\n}\n\n// Extract lines from the found section\nlet focusSectionLines = [];\nif (targetSectionStart !== -1) {\n  focusSectionLines = lines.slice(targetSectionStart + 1, targetSectionEnd);\n}\n\n// Define tag ‚Üí emoji mapping (priority order)\nconst tagEmojiMap = [\n  { tag: 'urgent', emoji: '‚ö°' },      // P0: Time-critical tasks\n  { tag: 'blocked', emoji: 'üöß' },    // P1: Blocked by external dependency\n  { tag: 'waiting', emoji: '‚è≥' },    // P2: Waiting for response/input\n  { tag: 'deepwork', emoji: 'üéØ' },   // P3: Requires focus/concentration\n  { tag: 'review', emoji: 'üëÅÔ∏è' }      // P4: Review/checking work\n];\n\n// Extract uncompleted tasks from the section\nconst uncompletedTasks = focusSectionLines\n  .filter(line => line.trim().match(/^-\\s*\\[\\s*\\]/))\n  .map(line => {\n    const taskText = line.trim();\n    \n    // Determine category based on content\n    let category = null;\n    if (taskText.match(/cortex\\//i)) {\n      category = 'Cortex';\n    } else if (taskText.match(/n8n|recipe\\s+\\d+/i)) {\n      category = 'n8n';\n    }\n    \n    // Extract tags from task text\n    const tags = [];\n    const tagPattern = /#(\\w+)/g;\n    let match;\n    while ((match = tagPattern.exec(taskText)) !== null) {\n      tags.push(match[1].toLowerCase());\n    }\n    \n    // Find matching emoji (first match in priority order)\n    let emoji = null;\n    for (const { tag, emoji: emojiChar } of tagEmojiMap) {\n      if (tags.includes(tag)) {\n        emoji = emojiChar;\n        break;\n      }\n    }\n    \n    return {\n      raw: taskText,\n      category: category,\n      text: taskText,\n      section: foundSection,\n      tags: tags,\n      emoji: emoji\n    };\n  });\n\n// Remove duplicates based on raw text\nconst seen = new Set();\nconst uniqueTasks = uncompletedTasks.filter(task => {\n  if (seen.has(task.raw)) {\n    return false;\n  }\n  seen.add(task.raw);\n  return true;\n});\n\nreturn {\n  json: {\n    date: dateInfo.date,\n    yesterdayDate: dateInfo.yesterdayDate,\n    todoPath: dateInfo.todoPath,\n    uncompletedTasks: uniqueTasks,\n    taskCount: uniqueTasks.length,\n    sourceSection: foundSection || 'None'\n  }\n};"
      },
      "id": "extract-tasks",
      "name": "Extract Uncompleted Tasks",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "https://host.docker.internal:27124/vault/TODO.md",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Bearer ' + $env.OBSIDIAN_API_KEY }}"
            }
          ]
        },
        "options": {
          "timeout": 10000,
          "allowUnauthorizedCerts": true
        }
      },
      "id": "read-todo",
      "name": "Read TODO.md",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1050, 300],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "const taskInfo = $('Extract Uncompleted Tasks').first().json;\nconst httpResponse = $input.first().json;\n\nfunction unwrapContent(raw) {\n  if (typeof raw !== 'string') return '';\n  let current = raw;\n  while (true) {\n    try {\n      const parsed = JSON.parse(current);\n      if (parsed && typeof parsed.content === 'string') {\n        current = parsed.content;\n        continue;\n      }\n      break;\n    } catch (e) {\n      break;\n    }\n  }\n  return current;\n}\n\n// Get existing TODO.md content (Obsidian REST: { content: \"...\" })\nlet todoContent = '';\n\nif (httpResponse && typeof httpResponse === 'object') {\n  if (typeof httpResponse.content === 'string') {\n    todoContent = unwrapContent(httpResponse.content);\n  } else if (typeof httpResponse.data === 'string') {\n    todoContent = unwrapContent(httpResponse.data);\n  } else if (typeof httpResponse.body === 'string') {\n    todoContent = unwrapContent(httpResponse.body);\n  } else if (httpResponse.data && typeof httpResponse.data.content === 'string') {\n    todoContent = unwrapContent(httpResponse.data.content);\n  }\n} else if (typeof httpResponse === 'string') {\n  todoContent = unwrapContent(httpResponse);\n}\n\nif (!todoContent) {\n  todoContent = '';\n}\n\n// Parse existing TODO sections\nconst lines = todoContent.split('\\n');\nconst existingTasks = lines\n  .filter(line => line.trim().match(/^\\-\\s*\\[/))\n  .map(line => line.trim());\n\n// Helper function to normalize task text for deduplication\nfunction normalizeTask(taskLine) {\n  return taskLine\n    .replace(/^-\\s*\\[\\s*\\]\\s*/, '')     // Remove checkbox\n    .replace(/^\\[.*?\\]\\s*/, '')          // Remove category prefix [Cortex], [n8n], etc.\n    .replace(/^[‚ö°üöß‚è≥üéØüëÅÔ∏è]\\s*/, '')     // Remove emoji + space (all 5 emojis)\n    .replace(/\\s*<!--.*?-->\\s*$/, '')   // Remove trailing HTML comment\n    .trim();\n}\n\n// Format new tasks with category, emoji, and tags\nconst formattedTasks = taskInfo.uncompletedTasks.map(task => {\n  // Remove the \"- [ ] \" prefix and any existing tags from content\n  let taskContent = task.raw.replace(/^-\\s*\\[\\s*\\]\\s*/, '');\n  \n  // Remove inline tags from the content (they'll be in the comment)\n  taskContent = taskContent.replace(/#\\w+/g, '').trim();\n  \n  // Build the formatted task\n  let formatted = '- [ ]';\n  \n  // Add category if exists\n  if (task.category) {\n    formatted += ` [${task.category}]`;\n  }\n  \n  // Add emoji if exists\n  if (task.emoji) {\n    formatted += ` ${task.emoji}`;\n  }\n  \n  // Add task content\n  formatted += ` ${taskContent}`;\n  \n  // Add tags comment if exists\n  if (task.tags && task.tags.length > 0) {\n    const tagsList = task.tags.map(t => `#${t}`).join(',');\n    formatted += `  <!-- ${tagsList} -->`;\n  }\n  \n  return formatted;\n});\n\n// Filter out tasks that already exist in TODO (compare normalized content only)\nconst newTasks = formattedTasks.filter(formattedTask => {\n  const newTaskNormalized = normalizeTask(formattedTask);\n  \n  return !existingTasks.some(existing => {\n    const existingNormalized = normalizeTask(existing);\n    return existingNormalized === newTaskNormalized;\n  });\n});\n\n// Build new section for today\nconst today = taskInfo.date;\nlet newSection = `\\n## Today ‚Äî ${today}\\n\\n`;\n\nif (newTasks.length > 0) {\n  newTasks.forEach(task => {\n    newSection += `${task}\\n`;\n  });\n} else {\n  newSection += '### High Priority\\nÔºà„Çø„Çπ„ÇØ„Å™„ÅóÔºâ\\n\\n';\n  newSection += '### Regular Tasks\\nÔºà„Çø„Çπ„ÇØ„Å™„ÅóÔºâ\\n\\n';\n}\n\nnewSection += '\\n---\\n';\n\n// Remove old \"## Today ‚Äî\" section if exists, then add new section\nconst updatedContent = todoContent.replace(\n  /## Today ‚Äî \\d{4}-\\d{2}-\\d{2}[\\s\\S]*?(?=\\n---|$)/,\n  ''\n).trim() + newSection;\n\nreturn {\n  json: {\n    date: today,\n    todoPath: taskInfo.todoPath,\n    newTasksCount: newTasks.length,\n    totalTasksCount: taskInfo.taskCount,\n    updatedContent,\n    newTasks,\n  },\n};"
      },
      "id": "merge-tasks",
      "name": "Merge Tasks into TODO",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "https://host.docker.internal:27124/vault/TODO.md",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Bearer ' + $env.OBSIDIAN_API_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { \"content\": $json.updatedContent } }}",
        "options": {
          "timeout": 10000,
          "allowUnauthorizedCerts": true
        }
      },
      "id": "update-todo",
      "name": "Update TODO.md",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1450, 300],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SLACK_DAILY_DIGEST_WEBHOOK }}",
        "authentication": "none",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { \"text\": \"‚úÖ TODO.md Auto-syncÂÆå‰∫Ü\\n‚Ä¢ Êó•‰ªò: \" + $('Merge Tasks into TODO').item.json.date + \"\\n‚Ä¢ Êñ∞Ë¶è„Çø„Çπ„ÇØ: \" + $('Merge Tasks into TODO').item.json.newTasksCount + \" ‰ª∂\\n‚Ä¢ „ÇΩ„Éº„Çπ: \" + $('Extract Uncompleted Tasks').item.json.sourceSection } }}",
        "options": {}
      },
      "id": "slack-notification",
      "name": "Send to Slack",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1650, 300],
      "onError": "continueRegularOutput"
    }
  ],
  "connections": {
    "Every Morning 08:05 JST": {
      "main": [
        [
          {
            "node": "Calculate Dates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Dates": {
      "main": [
        [
          {
            "node": "Read Latest Daily Digest",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Latest Daily Digest": {
      "main": [
        [
          {
            "node": "Extract Uncompleted Tasks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Uncompleted Tasks": {
      "main": [
        [
          {
            "node": "Read TODO.md",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read TODO.md": {
      "main": [
        [
          {
            "node": "Merge Tasks into TODO",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Tasks into TODO": {
      "main": [
        [
          {
            "node": "Update TODO.md",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update TODO.md": {
      "main": [
        [
          {
            "node": "Send to Slack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}
