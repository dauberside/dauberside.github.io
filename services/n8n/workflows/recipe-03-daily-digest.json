{
  "name": "Recipe 03: Daily Digest (Morning Summary)",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "hours",
              "hoursInterval": 24
            }
          ]
        },
        "triggerTimes": {
          "item": [
            {
              "hour": 8,
              "minute": 0
            }
          ]
        }
      },
      "id": "cron-trigger",
      "name": "Every Morning 08:00 JST",
      "type": "n8n-nodes-base.cron",
      "typeVersion": 1,
      "position": [250, 300]
    },
    {
      "parameters": {
        "jsCode": "// Calculate yesterday's date\nconst now = new Date();\nconst yesterday = new Date(now);\nyesterday.setDate(yesterday.getDate() - 1);\n\n// Format as YYYY-MM-DD\nconst year = yesterday.getFullYear();\nconst month = String(yesterday.getMonth() + 1).padStart(2, '0');\nconst day = String(yesterday.getDate()).padStart(2, '0');\nconst dateString = `${year}-${month}-${day}`;\n\n// Build file path for Obsidian daily note\nconst filePath = `cortex/daily/${dateString}-digest.md`;\n\nreturn {\n  json: {\n    date: dateString,\n    filePath: filePath\n  }\n};"
      },
      "id": "calculate-date",
      "name": "Calculate Yesterday's Date",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://host.docker.internal:27124/vault/{{ $json.filePath }}",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Bearer ' + $env.OBSIDIAN_API_KEY }}"
            }
          ]
        },
        "options": {
          "timeout": 10000,
          "allowUnauthorizedCerts": true
        }
      },
      "id": "get-obsidian-note",
      "name": "Get Daily Note from Obsidian",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [650, 300],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "method": "GET",
        "url": "=https://host.docker.internal:27124/vault/cortex/state/tomorrow.json",
        "authentication": "none",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "={{ 'Bearer ' + $env.OBSIDIAN_API_KEY }}"
            }
          ]
        },
        "options": {
          "timeout": 10000,
          "allowUnauthorizedCerts": true
        }
      },
      "id": "get-tomorrow-json",
      "name": "Get tomorrow.json",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [850, 200],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "append"
      },
      "id": "merge-sources",
      "name": "Merge Sources",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "jsCode": "// Recipe 03 v1.2: Morning Brief with tomorrow.json integration\n// Purpose: Generate \"Today's 3 Tasks\" with time estimates\n\nconst digestInput = $items(\"Get Daily Note from Obsidian\")[0]?.json || {};\nconst tomorrowInput = $items(\"Get tomorrow.json\")[0]?.json || {};\n\n// Parse digest content\nconst content = typeof digestInput === 'string'\n  ? digestInput\n  : (digestInput.data || digestInput.body || digestInput.content || '');\n\n// Extract date\nlet date = 'unknown';\nconst headerMatch = content.match(/^#\\s*Daily Digest[\\sâ€”-]+([\\d-]+)/m);\nconst frontMatterMatch = content.match(/^---[\\s\\S]+?date:\\s*([^\\n]+)[\\s\\S]+?---/);\nif (headerMatch) date = headerMatch[1];\nelse if (frontMatterMatch) date = frontMatterMatch[1].trim();\n\n// Parse tomorrow.json\nlet tomorrowData = {};\ntry {\n  if (typeof tomorrowInput === 'string') {\n    tomorrowData = JSON.parse(tomorrowInput);\n  } else if (tomorrowInput.content) {\n    tomorrowData = JSON.parse(tomorrowInput.content);\n  } else {\n    tomorrowData = tomorrowInput;\n  }\n} catch (e) {\n  // Fallback if parse fails\n  tomorrowData = {\n    tomorrow_candidates: [],\n    carryover_tasks: [],\n    reflection_summary: ''\n  };\n}\n\n// Build today's task list (priority: tomorrow_candidates)\nconst todayTasks = (tomorrowData.tomorrow_candidates || []).slice(0, 3);\nconst carryover = (tomorrowData.carryover_tasks || []).slice(0, 2);\nconst reflection = tomorrowData.reflection_summary || '';\n\n// Time estimation (simple heuristic)\n// - #urgent or âš¡: 1.5h\n// - #deepwork or ðŸŽ¯: 2h\n// - Regular: 1h\nfunction estimateTime(task) {\n  if (task.includes('#urgent') || task.includes('âš¡')) return 1.5;\n  if (task.includes('#deepwork') || task.includes('ðŸŽ¯')) return 2.0;\n  return 1.0;\n}\n\nconst taskWithTime = todayTasks.map((task, i) => {\n  const time = estimateTime(task);\n  return `${i + 1}. ${task} (${time}h)`;\n});\n\nconst totalTime = todayTasks.reduce((sum, task) => sum + estimateTime(task), 0);\nconst buffer = Math.ceil(totalTime * 0.2); // 20% buffer\n\n// Build Slack message\nlet message = `â˜€ï¸ *Morning Brief â€” ${date}*\\n\\n`;\n\nif (todayTasks.length > 0) {\n  message += `ðŸ“Œ *Today's Focus (Top 3)*\\n`;\n  for (const taskLine of taskWithTime) {\n    message += `${taskLine}\\n`;\n  }\n  message += `\\nâ± *Time Budget*: ${totalTime}h + ${buffer}h buffer = ${totalTime + buffer}h\\n\\n`;\n} else {\n  message += `ðŸ“Œ *Today's Focus*\\nï¼ˆã‚¿ã‚¹ã‚¯ãªã— - tomorrow.json ã‚’ç¢ºèªã—ã¦ãã ã•ã„ï¼‰\\n\\n`;\n}\n\nif (carryover.length > 0) {\n  message += `ðŸ”„ *Carryover from Yesterday*\\n`;\n  for (const task of carryover) {\n    message += `- ${task}\\n`;\n  }\n  message += `\\n`;\n}\n\nif (reflection) {\n  message += `ðŸ’­ *Yesterday's Reflection*\\n${reflection}`;\n}\n\nreturn {\n  json: {\n    date,\n    text: message,\n    todayTasks,\n    totalTime,\n    buffer,\n    carryover,\n  },\n};"
      },
      "id": "parse-markdown",
      "name": "Build Morning Brief",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $env.SLACK_DAILY_DIGEST_WEBHOOK }}",
        "authentication": "none",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ { \"text\": $json.text } }}",
        "options": {}
      },
      "id": "slack-notification",
      "name": "Send to Slack",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1450, 300],
      "onError": "continueRegularOutput"
    }
  ],
  "connections": {
    "Every Morning 08:00 JST": {
      "main": [
        [
          {
            "node": "Calculate Yesterday's Date",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Yesterday's Date": {
      "main": [
        [
          {
            "node": "Get Daily Note from Obsidian",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Daily Note from Obsidian": {
      "main": [
        [
          {
            "node": "Get tomorrow.json",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get tomorrow.json": {
      "main": [
        [
          {
            "node": "Merge Sources",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge Sources": {
      "main": [
        [
          {
            "node": "Build Morning Brief",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Morning Brief": {
      "main": [
        [
          {
            "node": "Send to Slack",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2025-11-18T00:00:00.000Z",
      "updatedAt": "2025-11-18T00:00:00.000Z",
      "id": "1",
      "name": "phase-2"
    },
    {
      "createdAt": "2025-11-18T00:00:00.000Z",
      "updatedAt": "2025-11-18T00:00:00.000Z",
      "id": "3",
      "name": "obsidian"
    }
  ],
  "triggerCount": 0,
  "updatedAt": "2025-11-18T00:00:00.000Z",
  "versionId": "1"
}
